import matplotlib.pyplot as plt
import csv
import argparse
import numpy as np
import sys
import tkinter as tk
from tkinter import ttk

"Written by Tim Solfronk, based on the version 'csv_to_plot.py' of Marc Marot-Lassauzaie"
"I use this file to convert data from the .csv files generated by the parsers to somewhat legible plots with UI selection."

ROW_AMOUNT = 3              # How many rows of plots there should be (-> influences how many columns will be needed)
ROUND_TO = 12               # To how many digits after the comma it should be rounded
OFFSET_TO_CENTER = 20.

# What the name of each data column is (for reference solution we look for an entry in the first two lines of the .csv file)
NAME_CONFIGS = { "tpv": [
                    "n-vel (x)",
                    "v-vel (y)",
                    "h-vel (z)",
                    "n_stress (σ_xx)",
                    "v_stress (σ_yy)",
                    "σ_zz",
                    "v-shear-stress (σ_xy)",
                    "h-shear-stress (σ_xz)",
                    "σ_yz",
                    "n-displacement (x)",
                    "v-displacement (y)",
                    "h-displacement (z)"],
                "loh": [
                    "x-vel",
                    "y-vel",
                    "z-vel",
                    "sigma_xx",
                    "sigma_yy",
                    "sigma_zz",
                    "sigma_xy",
                    "sigma_xz",
                    "sigma_yz"]
}

# every config is an array of exactly 3 elements
#   1. Array of ids of the data plots to show (e.g. [0,1,2] -> show var 1, 2 and 3)
#   2. Name config
#   3. A boolean that states if the coordinates should be offset by (-20, 0, -20) (needed for dynamic rupture simulations) 
SCENARIO_CONFIGS = {
    "tpv5": [[7,11,2,6,10,1], NAME_CONFIGS["tpv"],True],
    "tpv26":[[7,11,2,6,10,1], NAME_CONFIGS["tpv"],True],
    "tpv28":[[7,11,2,6,10,1], NAME_CONFIGS["tpv"],True],
    "tpv29":[[7,11,2,6,10,1], NAME_CONFIGS["tpv"],True],
    "loh1":[[0,1,2], NAME_CONFIGS["loh"],False],
    "reference":[[], NAME_CONFIGS["tpv"],True] # for reference it will always show all data plots by default
}


"""
Filter out only the data from tracers at the specified positions in the specified time
"""
def position_check(dataRow, pos):
    value = True
    if args.t_min!=None:
        value = value and float(dataRow[timeIndex])>=args.t_min
    if args.t_max!=None:
        value = value and float(dataRow[timeIndex])<=args.t_max
    
    for i in range(0,len(positionIndexes)):
        value = value and float(dataRow[positionIndexes[i]])==float(pos[i])
    return value


"""
Get all data for a specified position, and test if there really only is one tracer at this position
"""
def get_all_tracer_data(csvData, tracerPos):
    csvDataTracer = [data for data in csvData if position_check(data,tracerPos)]
    """
    Check how many tracers fit the filter by extracting the total numbers of number(0) and
    number(1) tuples that exist with the filter.
    The {number(0), number(1)} tuples should be unique for each tracer, therefore if there
    exists more than one value for either of these after filtering, there are multiple
    tracers that correspond to the filter.
    In the same way if there are none, none of the tracers correspond to the filter.
    """
    checkFirstIndexLength = set([data[firstNumberIndex] for data in csvDataTracer])
    checksecondIndexLength = set([data[secondNumberIndex] for data in csvDataTracer])

    if len(checkFirstIndexLength)==0:
        raise Exception("Specification was valid for none of the tracers, please check that a tracer exists at the specified position")
    elif len(checkFirstIndexLength)>1 or len(checksecondIndexLength) >1:
        raise Exception("Specification was valid for more than one tracer, please clarify which you want through use of positions x, y and z")

    return csvDataTracer


"""
Extract only the the time and specified variable data of the whole tracer data
"""
def get_specific_tracer_data(csvDataFiltered, offset):

    dt = []
    y = []

    for row in csvDataFiltered:
        dt.append(float(row[timeIndex]))
        y.append(float(row[dataIndex + offset]))

    """
    Sort this data in the direction of increasing time
    """

    dt, y = zip(*sorted(zip(dt,y)))
    return (dt, y)


"""
Plot the all the specified data of the given tracer
"""
def display_tracer_graphs(tracerPos):
    csvDataForTracer = get_all_tracer_data(csvData,tracerPos)

    global varsToPlot
    global varNames
    # If a reference solution is used, update that all variables should be plotted and update the names
    if args.scenario == "reference":
        varsToPlot = range(0,len(csvDataForTracer[0])-dataIndex)
        if tracerPos[0] == "20.0":
            varNames = ref_on_fault_names
        else:
            varNames = ref_off_fault_names

    # Setup layout of plots
    dataAmount = len(varsToPlot)
    columnAmount = dataAmount//ROW_AMOUNT + (1 if dataAmount%ROW_AMOUNT>0 else 0)
    fig, axs = plt.subplots(ROW_AMOUNT, columnAmount, figsize=(9, 13))
    fig.canvas.manager.set_window_title(simulationName + " at " + get_tracer_name(tracerPos))

    # for all variables to be plotted, fill out their subplot
    for i in range(dataAmount):
        dt, y = get_specific_tracer_data(csvDataForTracer, varsToPlot[i])
        currentPlot = axs[i%ROW_AMOUNT, i//ROW_AMOUNT] if columnAmount > 1 else axs[i]
        #currentPlot.plot(dt, y, color = 'b', linestyle = 'dashed', marker = 'o',label = "Variable " + str(i+1) + " as a function of time")
        varName = varNames[varsToPlot[i]]
        currentPlot.plot(dt, y, color = 'b', label = varName + " as a function of time")
        currentPlot.set_title(varName)
        currentPlot.set_xlabel('t')
        currentPlot.set_ylabel(varName)
        #currentPlot.legend()
        currentPlot.grid(True)
        currentPlot.set_xticks(xticks)

    plt.tight_layout()
    plt.show()


"""
Get the name of the tracer given its position
"""
def get_tracer_name(tracerPos):
    tracerName = "("
    coord_list = str(tracerPos)[1:-1].split(",")
    offset = OFFSET_TO_CENTER if SCENARIO_CONFIGS[args.scenario][2] else 0

    for i in range(len(coord_list)):
        match i:
            case 0:
                if not(args.scenario == "reference" and tracerPos[i] == "20.0"):
                    tracerName += "body " + str(round(float((coord_list[i].strip())[1:-1])-offset,ROUND_TO)) + ", "
            case 1:
                tracerName += "dip " + str(round(float((coord_list[i].strip())[1:-1]),ROUND_TO)) + ", "
            case 2:
                tracerName += "strike " + str(round(float((coord_list[i].strip())[1:-1])-offset,ROUND_TO)) + ", "

    tracerName = tracerName[:-2] + ")"

    # Uncomment below to see the curvi body positions in the interface
    #tracerName += " = " + str(float(get_all_tracer_data(csvData,tracerPos)[0][-3])) 

    return tracerName

"""
Convert a string like '1-3,5,6' -> [1,2,3,5,6]    (needed for argument v)
"""
def get_variable_ids(variableListString):
    variablesAmount = len(csvData[0])-dataIndex
    if variableListString == "":
        return range(variablesAmount)
    
    varEntries = variableListString.split(",")
    output = []

    for entryId in varEntries:
        if '-' in entryId:
            idRange = entryId.split('-')
            output.extend(range(int(idRange[0])-1,int(idRange[1])))
        elif int(entryId)-1 < variablesAmount:
            output.append(int(entryId)-1)
        else:
            print("Discarded id '" + entryId + "' of argument --v, because this id does not exist")

    return output


"""
Display a list of buttons with all tracers
"""
def show_tracer_ui():

    root = tk.Tk()
    root.title(simulationName)
    root.geometry("400x500")

    # Header label
    header = ttk.Label(root, text="Choose a tracer:", font=("Arial", 16, "bold"))
    header.pack(pady=10)

    # Scrollable Frame Setup 
    container = ttk.Frame(root)
    container.pack(fill="both", expand=True)

    canvas = tk.Canvas(container)
    scrollbar = ttk.Scrollbar(container, orient="vertical", command=canvas.yview)

    scrollable_frame = ttk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="n")
    canvas.configure(yscrollcommand=scrollbar.set)

    canvas.pack(side="left", fill="both", expand=True)
    scrollbar.pack(side="right", fill="y")

    # Create tracer buttons
    for i in range(0, len(tracers)):
        button = ttk.Button(scrollable_frame, text=get_tracer_name(tracers[i]), command=lambda idx=i: display_tracer_graphs(tracers[idx]))
        button.pack(fill="x", pady=5, padx=20)

    # Enable mouse wheel scrolling
    def _on_mousewheel(event):
        #Linux
        if event.num == 5 or event.delta < 0:
            canvas.yview_scroll(1, "units")
        elif event.num == 4 or event.delta > 0:
            canvas.yview_scroll(-1, "units")
        #Windows
        canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")
    # Windows
    canvas.bind_all("<MouseWheel>", _on_mousewheel)
    # Linux
    canvas.bind_all("<Button-4>", _on_mousewheel)
    canvas.bind_all("<Button-5>", _on_mousewheel)

    # Start the UI loop
    root.mainloop()


if __name__ == "__main__":
    """
    parse arguments to get details about which data should be extracted
    """
    parser = argparse.ArgumentParser(description='Script to convert CSV generated by ExaHyPE2 executions into plots')
    parser.add_argument("--f",               dest="file_name",      type=str,   required=True,  help="Name of the file to be checked, does not need to contain '.csv'" )
    parser.add_argument("--s",               dest="scenario",       type=str,   required=True,  help="Name of the scenario (needed to show only important data)", choices=SCENARIO_CONFIGS.keys() )
    parser.add_argument("--v",               dest="v",              type=str,   default="",     help="A comma seperated list of the variables to be plotted (e.g. --v '1-4,8' to plot the first 4 and the 8th )" )
    parser.add_argument("--tmax",            dest="t_max",          type=float, default=None,   help="Minimal time for which data should be plotted" )
    parser.add_argument("--tmin",            dest="t_min",          type=float, default=None,   help="Maximal time for which data should be plotted" )
    args = parser.parse_args()

    """
    Extract some metadata about the positions of the various information in the csv file.
    These should always be the same but it's safer to check.
    """
    try:
        csvData = list(csv.reader(open(args.file_name,'r'), delimiter=','))
    except FileNotFoundError:
        try:
            csvData = list(csv.reader(open(args.file_name + '.csv','r'), delimiter=','))
        except:
            print("the file you have specified does not exist, please make sure that it does in the specified location")
            exit()

    # if looking at a reference solutions, get the variable names from the first 2 lines of the .csv file
    if args.scenario == "reference":
        ref_on_fault_names = []
        ref_off_fault_names = []
        temp = csvData[0][0].split(" ")
        for i in range(3,len(temp)):
            if temp[i].strip() != "":
                ref_on_fault_names.append(temp[i].strip())
        temp = csvData[1][0].split(" ")
        for i in range(3,len(temp)):
            if temp[i].strip() != "":
                ref_off_fault_names.append(temp[i].strip())
        csvData = csvData[2:]

    # get indices
    timeIndex = csvData[0].index(' t')
    dataIndex = csvData[0].index(" data ") 
    firstNumberIndex = csvData[0].index('number(0)')
    secondNumberIndex = csvData[0].index(' number(1)')
    if ' x(2)' in csvData[0]:
        positionIndexes = [csvData[0].index(' x(0)'), csvData[0].index(' x(1)'), csvData[0].index(' x(2)')]
    else:
        positionIndexes = [csvData[0].index(' x(0)'), csvData[0].index(' x(1)')]

    """
    remove first row which should only contain metadata
    """
    csvData = csvData[1:-1]

    # extract tracers from csvData
    tracers = list(dict.fromkeys([tuple(data[i] for i in positionIndexes) for data in csvData]))

    # configure rest of command arguments
    simulationName = (args.file_name.split("/")[-1])[:-4]
    simulationTime = max(float(row[timeIndex]) for row in csvData)
    if args.t_min==None:
        args.t_min = 0
    if args.t_max==None or args.t_max > simulationTime:
        args.t_max = simulationTime
    xticks = np.arange(0,args.t_max,1)

    if args.v != "":
        varsToPlot = get_variable_ids(args.v)
    else:
        varsToPlot = SCENARIO_CONFIGS[args.scenario][0]
    # read in variable names
    varNames = SCENARIO_CONFIGS[args.scenario][1]
    
    for i in range(len(varNames), len(csvData[0])-dataIndex):
        varNames.append("Variable " + str(i))

    show_tracer_ui()


