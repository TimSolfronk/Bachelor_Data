import matplotlib.pyplot as plt
import csv
import argparse
import numpy as np
import sys
import tkinter as tk
from tkinter import ttk

"Written by Tim Solfronk, based on the version 'csv_to_plot.py' of Marc Marot-Lassauzaie"
"I use this file to convert data from the .csv files generated by the parsers to somewhat legible plots with UI selection."

ROW_AMOUNT = 3
ROUND_TO = 12               # To how many digits after the comma it should be rounded
OFFSET_TO_CENTER = 20.
last_strike = 10000
same_strike_in_row = 1

NAME_CONFIGS = { "tpv": [
                    "n-vel (x)",
                    "v-vel (y)",
                    "h-vel (z)",
                    "n_stress (σ_xx)",
                    "v_stress (σ_yy)",
                    "σ_zz",
                    "v-shear-stress (σ_xy)",
                    "h-shear-stress (σ_xz)",
                    "σ_yz",
                    "n-displacement (x)",
                    "v-displacement (y)",
                    "h-displacement (z)"],
                "loh": [
                    "x-vel",
                    "y-vel",
                    "z-vel",
                    "sigma_xx",
                    "sigma_yy",
                    "sigma_zz",
                    "sigma_xy",
                    "sigma_xz",
                    "sigma_yz"]
}

SCENARIO_CONFIGS = {
    "tpv5": [[
            7,
            11,
            2,
            6,
            10,
            1
    ], NAME_CONFIGS["tpv"],True],
    "tpv26":[[
            7,
            11,
            2,
            6,
            10,
            1
    ], NAME_CONFIGS["tpv"],True],
    "tpv28":[[
            7,
            11,
            2,
            6,
            10,
            1
    ], NAME_CONFIGS["tpv"],True],
    "tpv29":[[
            7,
            11,
            2,
            6,
            10,
            1
    ], NAME_CONFIGS["tpv"],True],
    "loh1":[[
            0,
            1,
            2
    ], NAME_CONFIGS["loh"],False],
    "custom":[[
            0,
            1,
            2,
    ], NAME_CONFIGS["tpv"],True]
}

"""
Filter out only the data from tracers at the specified positions
"""
def position_check(dataRow, pos):
    value = True
    if args.t_min!=None:
        value = value and float(dataRow[timeIndex])>=args.t_min
    if args.t_max!=None:
        value = value and float(dataRow[timeIndex])<=args.t_max
    
    for i in range(0,len(positionIndexes)):
        value = value and float(dataRow[positionIndexes[i]])==float(pos[i])
    return value


def get_all_tracer_data(csvData, tracerPos):
    csvDataTracer = [data for data in csvData if position_check(data,tracerPos)]


    """
    Check how many tracers fit the filter by extracting the total numbers of number(0) and
    number(1) tuples that exist with the filter.
    The {number(0), number(1)} tuples should be unique for each tracer, therefore if there
    exists more than one value for either of these after filtering, there are multiple
    tracers that correspond to the filter.
    In the same way if there are none, none of the tracers correspond to the filter.
    """
    checkFirstIndexLength = set([data[firstNumberIndex] for data in csvDataTracer])
    checksecondIndexLength = set([data[secondNumberIndex] for data in csvDataTracer])

    if len(checkFirstIndexLength)==0:
        raise Exception("Specification was valid for none of the tracers, please check that a tracer exists at the specified position")
    elif len(checkFirstIndexLength)>1 or len(checksecondIndexLength) >1:
        raise Exception("Specification was valid for more than one tracer, please clarify which you want through use of positions x, y and z")

    return csvDataTracer


    """
    Extract only the data from time and from the required value
    """
def get_specific_tracer_data(csvDataFiltered, offset):

    dt = []
    y = []

    for row in csvDataFiltered:
        dt.append(float(row[timeIndex]))
        y.append(float(row[dataIndex + offset]))

    """
    Sort this data in the direction of increasing time
    """

    dt, y = zip(*sorted(zip(dt,y)))
    return (dt, y)


    """
    Plot the all the specified data of the given tracer
    """
def display_tracer_graphs(tracerPos):
    csvDataForTracer = get_all_tracer_data(csvData,tracerPos)

    dataAmount = len(varsToPlot)
    columnAmount = dataAmount//ROW_AMOUNT + (1 if dataAmount%ROW_AMOUNT>0 else 0)
    fig, axs = plt.subplots(ROW_AMOUNT, columnAmount, figsize=(9, 13))
    fig.canvas.manager.set_window_title(simulationName + " at " + get_tracer_name(tracerPos))

    for i in range(dataAmount):
        dt, y = get_specific_tracer_data(csvDataForTracer, varsToPlot[i])
        currentPlot = axs[i%ROW_AMOUNT, i//ROW_AMOUNT] if columnAmount > 1 else axs[i]
        #currentPlot.plot(dt, y, color = 'b', linestyle = 'dashed', marker = 'o',label = "Variable " + str(i+1) + " as a function of time")
        varName = varNames[varsToPlot[i]]
        currentPlot.plot(dt, y, color = 'b', label = varName + " as a function of time")
        currentPlot.set_title(varName)
        currentPlot.set_xlabel('t')
        currentPlot.set_ylabel(varName)
        #currentPlot.legend()
        currentPlot.grid(True)
        currentPlot.set_xticks(xticks)

    plt.tight_layout()
    plt.show()


def get_tracer_name(tracerPos):
    tracerName = "("
    coord_list = str(tracerPos)[1:-1].split(",")
    offset = OFFSET_TO_CENTER if SCENARIO_CONFIGS[args.scenario][2] else 0

    for i in range(len(coord_list)):
        match i:
            case 0:
                tracerName += "body " + str(round(float((coord_list[i].strip())[1:-1])-offset,ROUND_TO)) + ", "
            case 1:
                tracerName += "dip " + str(round(float((coord_list[i].strip())[1:-1]),ROUND_TO)) + ", "
            case 2:
                tracerName += "strike " + str(round(float((coord_list[i].strip())[1:-1])-offset,ROUND_TO)) + ", "
                global last_strike
                global same_strike_in_row
                if round(float((coord_list[i].strip())[1:-1])-offset,ROUND_TO) == last_strike:
                    same_strike_in_row += 1
                else :
                    same_strike_in_row = 1
                last_strike = round(float((coord_list[i].strip())[1:-1])-offset,ROUND_TO)

    tracerName = tracerName[:-2] + ")"

    # output cartesian tracer body position and compare with curvi body position:
    #print(str(round(float((coord_list[0].strip())[1:-1]),ROUND_TO)) + " = " + str(float(get_all_tracer_data(csvData,tracerPos)[0][-3])))
    tracerName += " = " + str(float(get_all_tracer_data(csvData,tracerPos)[0][-3])) + " " + str(same_strike_in_row)
    
    # print curve grid body position:
    #if round(float((coord_list[1].strip())[1:-1]),0) == 0.0 and round(float((coord_list[2].strip())[1:-1]),0) == 8.0:
        #print(str(get_all_tracer_data(csvData,tracerPos)[0][-3]) + " = " + str(float(get_all_tracer_data(csvData,tracerPos)[0][-3])))

    return tracerName

def get_variable_ids(variableListString):
    variablesAmount = len(csvData[0])-dataIndex
    if variableListString == "":
        return range(variablesAmount)
    
    varEntries = variableListString.split(",")
    output = []

    for entryId in varEntries:
        if '-' in entryId:
            idRange = entryId.split('-')
            output.extend(range(int(idRange[0])-1,int(idRange[1])))
        elif int(entryId)-1 < variablesAmount:
            output.append(int(entryId)-1)
        else:
            print("Discarded id '" + entryId + "' of argument --v, because this id does not exist")

    return output


def main():

    root = tk.Tk()
    root.title(simulationName)
    root.geometry("400x500")

    # Header label
    header = ttk.Label(root, text="Choose a tracer:", font=("Arial", 16, "bold"))
    header.pack(pady=10)

    # Scrollable Frame Setup 
    container = ttk.Frame(root)
    container.pack(fill="both", expand=True)

    canvas = tk.Canvas(container)
    scrollbar = ttk.Scrollbar(container, orient="vertical", command=canvas.yview)

    scrollable_frame = ttk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="n")
    canvas.configure(yscrollcommand=scrollbar.set)

    canvas.pack(side="left", fill="both", expand=True)
    scrollbar.pack(side="right", fill="y")

    # Create buttons from list
    for i in range(0, len(tracers)):
        button = ttk.Button(scrollable_frame, text=get_tracer_name(tracers[i]), command=lambda idx=i: display_tracer_graphs(tracers[idx]))
        button.pack(fill="x", pady=5, padx=20)

    # Enable mouse wheel scrolling
    def _on_mousewheel(event):
        #Linux
        if event.num == 5 or event.delta < 0:
            canvas.yview_scroll(1, "units")
        elif event.num == 4 or event.delta > 0:
            canvas.yview_scroll(-1, "units")

        #Windows
        canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")

    # Windows
    canvas.bind_all("<MouseWheel>", _on_mousewheel)

    # Linux
    canvas.bind_all("<Button-4>", _on_mousewheel)
    canvas.bind_all("<Button-5>", _on_mousewheel)

    # Start the UI loop
    root.mainloop()


if __name__ == "__main__":
    """
    parse arguments to get details about which data should be extracted
    """

    parser = argparse.ArgumentParser(description='Script to convert CSV generated by ExaHyPE2 executions into plots')
    parser.add_argument("--f",               dest="file_name",      type=str,   required=True,  help="Name of the file to be checked, does not need to contain '.csv'" )
    parser.add_argument("--s",               dest="scenario",       type=str,   required=True,  help="Name of the scenario (needed to show only important data)", choices=SCENARIO_CONFIGS.keys() )
    parser.add_argument("--v",               dest="v",              type=str,   default="",     help="A comma seperated list of the variables to be plotted (e.g. --v '1-4,8' to plot the first 4 and the 8th )" )
    parser.add_argument("--tmax",            dest="t_max",          type=float, default=None,   help="Minimal time for which data should be plotted" )
    parser.add_argument("--tmin",            dest="t_min",          type=float, default=None,   help="Maximal time for which data should be plotted" )
    args = parser.parse_args()

    """f
    Extract some metadata about the positions of the various information in the csv file.
    These should always be the same but it's safer to check.
    """
    try:
        csvData = list(csv.reader(open(args.file_name,'r'), delimiter=','))
    except FileNotFoundError:
        try:
            csvData = list(csv.reader(open(args.file_name + '.csv','r'), delimiter=','))
        except:
            print("the file you have specified does not exist, please make sure that it does in the specified location")
            exit()


    timeIndex = csvData[0].index(' t')
    dataIndex = csvData[0].index(" data ") #+ args.v
    firstNumberIndex = csvData[0].index('number(0)')
    secondNumberIndex = csvData[0].index(' number(1)')
    if ' x(2)' in csvData[0]:
        positionIndexes = [csvData[0].index(' x(0)'), csvData[0].index(' x(1)'), csvData[0].index(' x(2)')]
    else:
        positionIndexes = [csvData[0].index(' x(0)'), csvData[0].index(' x(1)')]

    """
    remove first row which should only contain metadata
    """
    csvData = csvData[1:-1]
    tracers = list(dict.fromkeys([tuple(data[i] for i in positionIndexes) for data in csvData]))
    simulationName = (args.file_name.split("/")[-1])[:-4]
    simulationTime = max(float(row[timeIndex]) for row in csvData)
    if args.t_min==None:
        args.t_min = 0
    if args.t_max==None or args.t_max > simulationTime:
        args.t_max = simulationTime
    xticks = np.arange(0,args.t_max,1)

    #varsToPlot = get_variable_ids(args.v)
    if args.v != "":
            varsToPlot = get_variable_ids(args.v)
    else:
        varsToPlot = SCENARIO_CONFIGS[args.scenario][0]
    # read in variable names
    varNames = SCENARIO_CONFIGS[args.scenario][1]
    
    for i in range(len(varNames), len(csvData[0])-dataIndex):
        varNames.append("Variable " + str(i))

    
    
    main()


