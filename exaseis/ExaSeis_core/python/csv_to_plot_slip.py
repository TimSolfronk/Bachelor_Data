import matplotlib.pyplot as plt
import csv
import argparse
import numpy as np
import sys
import tkinter as tk
from tkinter import ttk

"Written by Marc Marot-Lassauzaie, I use this file to convert data from the .csv files generated by the parsers to somewhat legible plots"

ROW_AMOUNT = 3
ROUND_TO = 12
OFFSET_TO_CENTER = 20.
MAX_ON_FAULT_OFFSET = 1.

NAME_CONFIG = { "on-fault": [
                    "n-slip-rate (x)",
                    "v-slip-rate (y)",
                    "h-slip-rate (z)",
                    "n_stress (σ_xx)",
                    "v_stress (σ_yy)",
                    "σ_zz",
                    "v-shear-stress (σ_xy)",
                    "h-shear-stress (σ_xz)",
                    "σ_yz",
                    "n-slip (x)",
                    "v-slip (y)",
                    "h-slip (z)"],
                "off-fault": [
                    "n-vel (x)",
                    "v-vel (y)",
                    "h-vel (z)",
                    "n_stress (σ_xx)",
                    "v_stress (σ_yy)",
                    "σ_zz",
                    "v-shear-stress (σ_xy)",
                    "h-shear-stress (σ_xz)",
                    "σ_yz",
                    "n-displacement (x)",
                    "v-displacement (y)",
                    "h-displacement (z)"]}

ON_FAULT_SUB = [True,True,True,False,False,False,False,False,False,True,True,True]

SCENARIOS_SHOW_CONFIG = {
    "tpv5": { 
        "on-fault": [
            7,
            11,
            2,
            6,
            10,
            1
        ],
        "off-fault": [
            11,
            2,
            9,
            0,
            10,
            1
        ]
    },
    "tpv26":{
        "on-fault": [
            7,
            11,
            2,
            3,
            6,
            10,
            1
        ],
        "off-fault": [
            11,
            2,
            9,
            0,
            10,
            1
        ]
    },
    "tpv28":{
        "on-fault": [
            7,
            11,
            2,
            3,
            6,
            10,
            1
        ],
        "off-fault": [
            11,
            2,
            9,
            0,
            10,
            1
        ]
    },
    "tpv29":{
        "on-fault": [
            7,
            11,
            2,
            3,
            6,
            10,
            1
        ],
        "off-fault": [
            11,
            2,
            9,
            0,
            10,
            1
        ]
    }
}




"""
Filter out only the data from tracers at the specified positions
"""
def position_check(dataRow, pos):
    value = True
    if args.t_min!=None:
        value = value and float(dataRow[timeIndex])>=args.t_min
    if args.t_max!=None:
        value = value and float(dataRow[timeIndex])<=args.t_max
    
    for i in range(0,len(positionIndexes)):
        value = value and float(dataRow[positionIndexes[i]])==float(pos[i])
    return value


def get_all_tracer_data(csvData, tracerPos):
    csvDataTracer = [data for data in csvData if position_check(data,tracerPos)]


    """
    Check how many tracers fit the filter by extracting the total numbers of number(0) and
    number(1) tuples that exist with the filter.
    The {number(0), number(1)} tuples should be unique for each tracer, therefore if there
    exists more than one value for either of these after filtering, there are multiple
    tracers that correspond to the filter.
    In the same way if there are none, none of the tracers correspond to the filter.
    """
    checkFirstIndexLength = set([data[firstNumberIndex] for data in csvDataTracer])
    checksecondIndexLength = set([data[secondNumberIndex] for data in csvDataTracer])

    if len(checkFirstIndexLength)==0:
        raise Exception("Specification was valid for none of the tracers, please check that a tracer exists at the specified position")
    elif len(checkFirstIndexLength)>1 or len(checksecondIndexLength) >1:
        raise Exception("Specification was valid for more than one tracer, please clarify which you want through use of positions x, y and z")

    return csvDataTracer


    """
    Extract only the data from time and from the required value
    """
def get_specific_tracer_data(csvDataFiltered, offset):

    dt = []
    y = []

    for row in csvDataFiltered:
        dt.append(float(row[timeIndex]))
        y.append(float(row[dataIndex + offset]))

    """
    Sort this data in the direction of increasing time
    """

    dt, y = zip(*sorted(zip(dt,y)))
    return (dt, y)


    """
    Plot all the specified data of the given tracer
    """
def display_tracer_graphs(tracerPos):
    csvDataForTracer = get_all_tracer_data(csvData,tracerPos)
    faultStatus = "off-fault"

    if not is_off_fault(tracerPos) and is_on_far_side(tracerPos): 
        csvDataSub = get_all_tracer_data(csvData, get_other_side_on_fault_tracers(tracerPos)[0])
        faultStatus = "on-fault"
        dataLength = min(len(csvDataForTracer), len(csvDataSub))
        csvDataForTracer = csvDataForTracer[:dataLength]
        csvDataSub = csvDataSub[:dataLength]
        for i in range(len(csvDataForTracer)):
            for j in range(len(ON_FAULT_SUB)):
                if ON_FAULT_SUB[j]:
                    csvDataForTracer[i][dataIndex+j] = float(csvDataForTracer[i][dataIndex+j]) - float(csvDataSub[i][dataIndex+j])


    dataAmount = len(varsToPlot[faultStatus])
    columnAmount = dataAmount//ROW_AMOUNT + (1 if dataAmount%ROW_AMOUNT>0 else 0)
    fig, axs = plt.subplots(ROW_AMOUNT, columnAmount, figsize=(9, 13))
    fig.canvas.manager.set_window_title(simulationName + " at " + get_tracer_name(tracerPos))

    for i in range(dataAmount):
        dt, y = get_specific_tracer_data(csvDataForTracer, varsToPlot[faultStatus][i])
        currentPlot = axs[i%ROW_AMOUNT, i//ROW_AMOUNT] if columnAmount > 1 else axs[i]
        #currentPlot.plot(dt, y, color = 'b', linestyle = 'dashed', marker = 'o',label = "Variable " + str(i+1) + " as a function of time")
        varName = NAME_CONFIG[faultStatus][varsToPlot[faultStatus][i]]
        currentPlot.plot(dt, y, color = 'b', label = varName + " as a function of time")
        currentPlot.set_title(varName)
        currentPlot.set_xlabel('t')
        currentPlot.set_ylabel(varName)
        #currentPlot.legend()
        currentPlot.grid(True)
        currentPlot.set_xticks(xticks)

    plt.tight_layout()
    plt.show()


def get_tracer_name(tracerPos):
    tracerName = "("
    coord_list = str(tracerPos)[1:-1].split(",")

    for i in range(len(coord_list)):
        match i:
            case 0:
                if is_off_fault(tracerPos):
                    tracerName += "body " + str(round(float((coord_list[i].strip())[1:-1])-OFFSET_TO_CENTER,ROUND_TO)) + ", "
            case 1:
                tracerName += "dip " + str(round(float((coord_list[i].strip())[1:-1]),ROUND_TO)) + ", "
            case 2:
                tracerName += "strike " + str(round(float((coord_list[i].strip())[1:-1])-OFFSET_TO_CENTER,ROUND_TO)) + ", "

    tracerName = tracerName[:-2] + ")"
    return tracerName

def get_variable_ids(variableListString):
    variablesAmount = len(csvData[0])-dataIndex
    if variableListString == "":
        return range(variablesAmount)
    
    varEntries = variableListString.split(",")
    output = []

    for entryId in varEntries:
        if '-' in entryId:
            idRange = entryId.split('-')
            output.extend(range(int(idRange[0])-1,int(idRange[1])))
        elif int(entryId)-1 < variablesAmount:
            output.append(int(entryId))
        else:
            print("Discarded id '" + entryId + "' of argument --v, because this id does not exist")

    return output

def is_off_fault(tracerPos):
    return abs(float(tracerPos[0])-OFFSET_TO_CENTER) > MAX_ON_FAULT_OFFSET or get_other_side_on_fault_tracers(tracerPos) == []

def is_on_far_side(tracerPos):
    possibleOtherSide = get_other_side_on_fault_tracers(tracerPos)
    return float(tracerPos[0]) > float(possibleOtherSide[0][0])

def get_other_side_on_fault_tracers(tracerPos):
    possibleOtherSide = []
    for tracer in tracers:
        if tracer[1] == tracerPos[1] and tracer[2] == tracerPos[2] and tracer[0] != tracerPos[0] and abs(float(tracer[0])-OFFSET_TO_CENTER) <= MAX_ON_FAULT_OFFSET:
            possibleOtherSide.append(tracer)
    return possibleOtherSide


def main():
    root = tk.Tk()
    root.title(simulationName)
    root.geometry("400x500")

    # Header label
    header = ttk.Label(root, text="Choose a tracer:", font=("Arial", 16, "bold"))
    header.pack(pady=10)

    # Scrollable Frame Setup 
    container = ttk.Frame(root)
    container.pack(fill="both", expand=True)

    canvas = tk.Canvas(container)
    scrollbar = ttk.Scrollbar(container, orient="vertical", command=canvas.yview)

    scrollable_frame = ttk.Frame(canvas)

    scrollable_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
    )

    canvas.create_window((0, 0), window=scrollable_frame, anchor="n")
    canvas.configure(yscrollcommand=scrollbar.set)

    canvas.pack(side="left", fill="both", expand=True)
    scrollbar.pack(side="right", fill="y")

    # Create buttons from list
    for i in range(0, len(tracers)):
        if is_off_fault(tracers[i]) or is_on_far_side(tracers[i]):
            button = ttk.Button(scrollable_frame, text=get_tracer_name(tracers[i]), command=lambda idx=i: display_tracer_graphs(tracers[idx]))
            button.pack(fill="x", pady=5, padx=20)

    # Enable mouse wheel scrolling
    def _on_mousewheel(event):
        #Linux
        if event.num == 5 or event.delta < 0:
            canvas.yview_scroll(1, "units")
        elif event.num == 4 or event.delta > 0:
            canvas.yview_scroll(-1, "units")

        #Windows
        canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")

    # Windows
    canvas.bind_all("<MouseWheel>", _on_mousewheel)

    # Linux
    canvas.bind_all("<Button-4>", _on_mousewheel)
    canvas.bind_all("<Button-5>", _on_mousewheel)

    # Start the UI loop
    root.mainloop()

if __name__ == "__main__":
    """
    parse arguments to get details about which data should be extracted
    """

    parser = argparse.ArgumentParser(description='Script to convert CSV generated by ExaHyPE2 executions into plots')
    parser.add_argument("--f",               dest="file_name",      type=str,   required=True,  help="Name of the file to be checked, does not need to contain '.csv'" )
    parser.add_argument("--s",               dest="scenario",       type=str,   required=True,  help="Name of the scenario (needed to show only important data)", choices=SCENARIOS_SHOW_CONFIG.keys() )
    parser.add_argument("--v",               dest="v",              type=str,   default="",     help="A comma seperated list of the variables to be plotted (e.g. --v '1-4,8' to plot the first 4 and the 8th )" )
    parser.add_argument("--tmax",            dest="t_max",          type=float, default=None,   help="Minimal time for which data should be plotted" )
    parser.add_argument("--tmin",            dest="t_min",          type=float, default=None,   help="Maximal time for which data should be plotted" )
    args = parser.parse_args()

    """f
    Extract some metadata about the positions of the various information in the csv file.
    These should always be the same but it's safer to check.
    """
    try:
        csvData = list(csv.reader(open(args.file_name,'r'), delimiter=','))
    except FileNotFoundError:
        try:
            csvData = list(csv.reader(open(args.file_name + '.csv','r'), delimiter=','))
        except:
            print("the file you have specified does not exist, please make sure that it does in the specified location")
            exit()


    timeIndex = csvData[0].index(' t')
    dataIndex = csvData[0].index(" data ") #+ args.v
    firstNumberIndex = csvData[0].index('number(0)')
    secondNumberIndex = csvData[0].index(' number(1)')
    if ' x(2)' in csvData[0]:
        positionIndexes = [csvData[0].index(' x(0)'), csvData[0].index(' x(1)'), csvData[0].index(' x(2)')]
    else:
        positionIndexes = [csvData[0].index(' x(0)'), csvData[0].index(' x(1)')]

    """
    remove first row which should only contain metadata
    """
    csvData = csvData[1:-1]


    tracers = list(dict.fromkeys([tuple(data[i] for i in positionIndexes) for data in csvData]))
    bodyCoords = list(set(coords[0] for coords in tracers))
    
    smallestBody = float('inf')
    secondSmallestBody = float('inf')
    for bodyCoord in bodyCoords:
        if abs(float(bodyCoord)-OFFSET_TO_CENTER) < abs(float(smallestBody)-OFFSET_TO_CENTER):
            secondSmallestBody = smallestBody
            smallestBody = bodyCoord
        elif abs(float(bodyCoord)-OFFSET_TO_CENTER) < abs(float(secondSmallestBody)-OFFSET_TO_CENTER):
            secondSmallestBody = bodyCoord

    simulationName = (args.file_name.split("/")[-1])[:-4]
    simulationTime = max(float(row[timeIndex]) for row in csvData)
    if args.t_min==None:
        args.t_min = 0
    if args.t_max==None or args.t_max > simulationTime:
        args.t_max = simulationTime
    xticks = np.arange(0,args.t_max,1)

    if args.v != "":
        varsToPlot = {"on-fault":get_variable_ids(args.v),"off-fault":get_variable_ids(args.v)}
    else:
        varsToPlot = SCENARIOS_SHOW_CONFIG.get(args.scenario)

    main()


